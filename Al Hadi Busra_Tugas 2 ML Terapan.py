# -*- coding: utf-8 -*-
"""Tugas ML Terapan 2 Fix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uFYE4475-_SoVAbNZZq_mrrXHL3qIK9D

## Import Libary
"""

# Pemrosesan Data
import pandas as pd

# Visualisasi Data
import matplotlib.pyplot as plt

# Pemrosesan Teks dan Ekstraksi Fitur
from sklearn.feature_extraction.text import TfidfVectorizer

# Mengukur Kemiripan
from sklearn.metrics.pairwise import cosine_similarity

# Evaluasi Model
from sklearn.metrics import precision_score

# Operasi Numerik
import numpy as np

# Pengelolaan Dataset Kaggle
import kagglehub

"""## Mendowload Data"""

# Download latest version
path = kagglehub.dataset_download("mohneesh7/indian-medicine-data")

print("Path to dataset files:", path)

"""## Data Understanding"""

# Link atau path ke file dataset yang ada di lingkungan Kaggle
link = "/kaggle/input/indian-medicine-data/medicine_data.csv"

# Membaca file CSV dan menyimpannya ke dalam DataFrame
medicine = pd.read_csv(link)

# Menampilkan 10 baris pertama dari dataset
medicine.head(10)

# Menampilkan bentuk dari DataFrame (jumlah baris dan kolom)
medicine.shape

# Menampilkan ringkasan informasi tentang dataset
medicine.info()

"""Dari tebel diatas dapat dilihat bahwa dataset memiliki 8 kolom dengan tipe object. Dataset terdiri 195605 baris yang menandakan bahwa terdapat 195605 data obat pada dataset"""

# Menampilkan jumlah nilai unik (nunique) pada setiap kolom

print('Jumlah Sub Kategori: ', medicine.sub_category.nunique())
print('Jumlah Produk Name: ', medicine.product_name.nunique())
print('Jumlah Komposisi Obat: ', medicine.salt_composition.nunique())
print('Jumlah Product Price: ', medicine.product_price.nunique())
print('Jumlah Medicine Desc: ', medicine.medicine_desc.nunique())
print('Jumlah Side Effect: ', medicine.side_effects.nunique())
print('Jumlah Drug Interactions: ', medicine.drug_interactions.nunique())

"""Pada tabel, dapat dilihat bahwan fitur-fitur dataset memiliki nilai yang beragam. Ini menandakan bahwa ada kesamaan nilai pada fitur-fitur antar obat. Hal ini mengindikasikan ada kesamaan ciri-ciri antar obat pada dataset sehingga data cocok digunakan untuk project sistem rekomendasi pengganti obat."""

# Menampilkan jumlah nilai kosong (missing values) untuk setiap kolom dalam DataFrame
medicine.isnull().sum()

"""Dari tabel dapat dilihat bahwa terdapat satu fitur yang memiliki missing value yaitu product price. Tapi untuk project kita kali ini kita tidak akan menggunakan fitur product price, sehingga ini dapat dihapus pada dataset nantinya.

Pada project ini kita berfokus menggunakan 2 fitur pada data yaitu sub category dan salt composition, sehingga fitur seperti product price, product_manufactured, medicine desc, dan drug interactions akan dihapus pada dataset nantinya.

Karena kita menggunaka fitur sub kategori dan salt composition pada project ini, maka kita perlu memahami lebih lanjut terkait fitur-fitur ini.

### Histogram Jumlah Data per Kategori
"""

# Menghitung jumlah data per kategori
value_counts = medicine['sub_category'].value_counts()

# Menghitung distribusi frekuensi data tersebut
# Berapa banyak sub_kategori yang muncul dengan jumlah tertentu
# Contoh: Ada 10 kategori yang masing-masing muncul 3 kali
distribusi = value_counts.value_counts().sort_index()

# Meneentukan jumlah grup untuk memecah distribusi menjadi beberapa bagian agar lebih mudah dibaca
num_groups = 4
group_size = len(distribusi) // num_groups
if len(distribusi) % num_groups != 0:
    num_groups += 1  # Tambah satu grup jika ada sisa

# Membuat subplots
fig, axes = plt.subplots(num_groups, 1, figsize=(12, 6 * num_groups))

# Memastikan axes selalu list meskipun hanya 1 subplot
if num_groups == 1:
    axes = [axes]

# Memvisualisasi setiap grup secara terpisah untuk keterbacaan
for i in range(num_groups):
    start = i * group_size
    end = (i + 1) * group_size
    group_data = distribusi.iloc[start:end]

    # Membuat bar chart untuk grup
    bars = axes[i].bar(range(len(group_data)), group_data.values, color='orange')

    # Menambahkan label angka di atas setiap batang
    for bar in bars:
        height = bar.get_height()
        axes[i].text(bar.get_x() + bar.get_width()/2, height, f'{int(height)}',
                     ha='center', va='bottom', fontsize=9)

    # # Mengatur label sumbu x agar menunjukkan jumlah data per kategori (frekuensinya)
    axes[i].set_xticks(range(len(group_data)))
    axes[i].set_xticklabels(group_data.index, rotation=90)

    # Membuat label dan judul per subplot
    axes[i].set_xlabel('Jumlah Data')
    axes[i].set_ylabel('Jumlah Kategori')
    axes[i].set_title(f'Distribusi Jumlah Kategori per Jumlah Data - Bagian {i + 1}')
    axes[i].grid(axis='y', linestyle='--', alpha=0.7)

# Menata agar subplot tidak saling menimpa
plt.tight_layout()
plt.show()

"""Dari histogram dapat dilihat bahwa terdapat 25 jenis sub category yang memiliki 80 data dan ini merupakan jumlah data yang memiliki sub kategori terbanyak pada histogram. Selain itu, terdapat 25 jenis sub category yang memiliki jumlah data dibawah 5 serta beberapa jenis sub kategori yang memiliki jumlah data mencapai ribuan

### Histogram Jumlah Salt Composition per Jumlah Data
"""

# Menghitung jumlah data per kategori
value_counts = medicine['salt_composition'].value_counts()

# Menghitung distribusi frekuensi data tersebut
# Berapa banyak sub_kategori yang muncul dengan jumlah tertentu
# Contoh: Ada 10 kategori yang masing-masing muncul 3 kali
distribusi = value_counts.value_counts().sort_index()

# Meneentukan jumlah grup untuk memecah distribusi menjadi beberapa bagian agar lebih mudah dibaca
num_groups = 4
group_size = len(distribusi) // num_groups
if len(distribusi) % num_groups != 0:
    num_groups += 1  # Tambah satu grup jika ada sisa

# Membuat subplots
fig, axes = plt.subplots(num_groups, 1, figsize=(12, 6 * num_groups))

# Memastikan axes selalu list meskipun hanya 1 subplot
if num_groups == 1:
    axes = [axes]

# Memvisualisasi setiap grup secara terpisah untuk keterbacaan
for i in range(num_groups):
    start = i * group_size
    end = (i + 1) * group_size
    group_data = distribusi.iloc[start:end]

    # Membuat bar chart untuk grup
    bars = axes[i].bar(range(len(group_data)), group_data.values, color='orange')

    # Menambahkan label angka di atas setiap batang
    for bar in bars:
        height = bar.get_height()
        axes[i].text(bar.get_x() + bar.get_width()/2, height, f'{int(height)}',
                     ha='center', va='bottom', fontsize=9)

    # # Mengatur label sumbu x agar menunjukkan jumlah data per kategori (frekuensinya)
    axes[i].set_xticks(range(len(group_data)))
    axes[i].set_xticklabels(group_data.index, rotation=90)

    # Membuat label dan judul per subplot
    axes[i].set_xlabel('Jumlah Data')
    axes[i].set_ylabel('Jumlah Salt Composition')
    axes[i].set_title(f'Distribusi Jumlah Salt Composition per Jumlah Data - Bagian {i + 1}')
    axes[i].grid(axis='y', linestyle='--', alpha=0.7)

# Menata agar subplot tidak saling menimpa
plt.tight_layout()
plt.show()

"""Dari histogram dapat dilihat bahwa terdapat 242 jenis salt composition yang memiliki 1 data dan ini merupakan jumlah data yang memiliki jenis salt composition terbanyak pada histogram. Selain itu, terdapat beberapa jenis salt composition yang memiliki jumlah data mencapai ribuan.

### Pemahaman Lanjutan
"""

# Menghitung distribusi nilai untuk kolom salt_composition
medicine['sub_category'].value_counts()

# Menghitung distribusi nilai untuk kolom sub_category
medicine['salt_composition'].value_counts()

# Menampilkan baris dengan nilai sama di 'product_name', 'sub_category', dan 'salt_composition', tetapi berbeda pada 'product_manufactured'

# Memfilter data untuk mendapatkan kombinasi yang memiliki nilai berbeda pada 'product_manufacture'
filtered = medicine.groupby(['product_name', 'sub_category', 'salt_composition']) \
    .filter(lambda x: x['product_manufactured'].nunique() > 1)

# Memilih hanya kolom yang relevan
result_df = filtered[['product_name', 'sub_category', 'salt_composition', 'product_manufactured']]

# Menampilkan hasil sebagai DataFrame
pd.DataFrame(result_df)

"""Pada tabel diatas, dapat dilihat bahwa terdapat kesamaan product name, sub category, dan salt composition pada obat yang diproduksi pada beberapa manufaktur. Hal ini menunjukkan adanya sejumlah besar produk dengan informasi yang sangat mirip atau identik. Sehingga, data duplikat ini akan dihapus nantinya pada prose data preparation."""

# Mencari baris yang punya kombinasi sama antara product_name, sub_category, dan salt_composition
duplikat_kombinasi = medicine[medicine.duplicated(subset=['product_name', 'sub_category', 'salt_composition'], keep=False)]

# Menampilkan jumlah baris yang memiliki kombinasi duplikat
print(f"Jumlah baris dengan kombinasi duplikat: {len(duplikat_kombinasi)}")

# Menampilkan baris setelah diurutkan
duplikat_kombinasi.sort_values(by=['product_name', 'sub_category', 'salt_composition']).head(10)

# Menghitung jumlah kemunculan tiap kombinasi 'product_name', 'sub_category', dan 'salt_composition'
kombinasi_counts = medicine.groupby(['product_name', 'sub_category', 'salt_composition']).size().reset_index(name='count')

# Mengambil hanya kombinasi yang muncul lebih dari 1 kali
kombinasi_duplikat = kombinasi_counts[kombinasi_counts['count'] > 1]

# Menampilkan jumlah kombinasi duplikat
print(f"Jumlah kombinasi duplikat: {len(kombinasi_duplikat)}")

# Menampilkan 5 duplikat teratas berdasarkan jumlah kemunculan
kombinasi_duplikat.sort_values(by='count', ascending=False).head()

"""## Data Preparation

### Menghapus Fitur yang Tidak Digunakan

Pada project ini kita berfokus menggunakan 2 fitur pada data yaitu sub category dan salt composition, sehingga fitur seperti product price, product_manufactured, medicine desc, dan drug interactions kan dihapus pada dataset
"""

# Menghapus kolom-kolom yang tidak digunakan dalam sistem rekomendasi
medicine.drop(
    columns=[
        'product_price',
        'product_manufactured',
        'medicine_desc',
        'drug_interactions',
        'side_effects'
    ],
    inplace=True  # Perubahan langsung diterapkan ke DataFrame tanpa membuat salinan
)

# Menampilkan kolom-kolom yang tersisa setelah proses penghapusan
print(medicine.columns)

"""### Mengapus Data Kombinasi *Duplikat*

Data yang dihapus merupkan data yang memiliki nilai sama pada fitur product name, sub category, dan salt composition. Duplikasi data dapat menyebabkan sistem rekomendasi menjadi bias dan tidak efisien. Dengan menghapus data ganda, kita memastikan bahwa model hanya belajar dari informasi yang unik dan relevan, sehingga meningkatkan akurasi rekomendasi.
"""

# Mengambil kombinasi duplikat berdasarkan 'product_name', 'sub_category', dan 'salt_composition'
duplikat_rows = medicine[medicine.duplicated(subset=['product_name', 'sub_category', 'salt_composition'], keep=False)]

# Menghapus baris-baris  yang telah ditandai sebagai duplikat
medicine_cleaned = medicine.drop(duplikat_rows.index)

# Menampilkan jumlah baris sebelum dan sesudah penghapusan duplikat
print(f"Jumlah baris sebelum duplikat dihapus: {len(medicine)}")
print(f"Jumlah baris setelah duplikat dihapus: {len(medicine_cleaned)}")

medicine_cleaned.head()

# Menampilkan jumlah nilai unik (unique values) setelah proses penghapusan duplikat

print('Jumlah subkategori setelah drop: ', medicine_cleaned.sub_category.nunique())
print('Jumlah Produk Name setelah drop: ', medicine_cleaned.product_name.nunique())
print('Jumlah Komposisi Obat setelah drop: ', medicine_cleaned.salt_composition.nunique())

"""### Memfilter Data

Sub kategori yang memilki data dibawah 5 akan dihapus. Jumlah data yang terlalu sedikit pada suatu kategori membuat model sulit belajar pola yang kuat. Hal ini bisa menyebabkan overfitting atau hasil rekomendasi yang tidak akurat karena minimnya representasi dat
"""

# Menghitung jumlah data (frekuensi) untuk setiap sub-kategori
value_counts = medicine_cleaned['sub_category'].value_counts()

# Mengitung jumlah sub-kategori yang memiliki data kurang dari 5 (jarang muncul)
jumlah_kategori_dibawah_5 = (value_counts < 5).sum()
print(f"Jumlah katergori dengan jumlah datanya dibawah 5 : {jumlah_kategori_dibawah_5}")

# Menghitung jumlah data per subkategori
subcat_counts = medicine_cleaned['sub_category'].value_counts()

# Mengambil hanya subkategori yang jumlah datanya > 4
valid_subcats = subcat_counts[subcat_counts > 4].index

# Memfilter dataframe untuk hanya menyertakan subkategori yang valid (jumlah data > 4)
medicine_filtered = medicine_cleaned[medicine_cleaned['sub_category'].isin(valid_subcats)].copy()

# Mengecek hasil jumlah baris sebelum dan sesudah filter
print(f"Jumlah baris sebelum filter: {len(medicine_cleaned)}")
print(f"Jumlah baris sesudah filter: {len(medicine_filtered)}")

# Menampilkan jumlah nilai unik (unique values) setelah proses filtering

print(f"Jumlah data: {len(medicine)}")
print(f"Jumlah data sesudah drop: {len(medicine_cleaned)}")
print(f"Jumlah data sesudah filter: {len(medicine_filtered)}")

# Menampilkan jumlah nilai unik (unique values) untuk setiap tahapan pada fitur sub_category dan salt_composition

print('Jumlah Sub Kategori : ', medicine.sub_category.nunique())
print('Jumlah Salt Composition : ', medicine.salt_composition.nunique())
print('Jumlah Sub Kategori setelah drop: ', medicine_cleaned.sub_category.nunique())
print('Jumlah Salt Composition setelah drop: ', medicine_cleaned.salt_composition.nunique())
print('Jumlah Sub Kategori setelah filter: ', medicine_filtered.sub_category.nunique())
print('Jumlah Salt Composition setelah filter: ', medicine_filtered.salt_composition.nunique())

# Mereset index pada dataframe setelah filter, tanpa menambah kolom 'index'

medicine_filtered = medicine_filtered.reset_index(drop=True)

medicine_filtered.head()

"""### Normalisasi Data

Normalisasi data dilakukan pada Fitur Sub Category dan Salt Composition. Normalsisai dilakukan dengan cara Mengubah huruf menjadi huruf kecil (lowercase) dan menghapus karakter khusus seperti tanda baca atau simbol. Normalisasi membantu menyamakan format penulisan sehingga data yang secara semantik sama tapi tertulis berbeda dapat dikenali sebagai satu entitas.
"""

# Menstandarisasi kolom 'sub_category':
# - Mengubah semua huruf menjadi huruf kecil (lowercase)
# - Menghapus spasi kosong di awal/akhir string

medicine_filtered['sub_category'] = medicine_filtered['sub_category'].str.strip().str.lower()  # Menstandarisasi ke lowercase dan menghapus spasi ekstra

# Fungsi untuk menormalisasi komposisi garam (salt composition)
def normalize_salt_composition(comp):

    """
    Menormalisasi string komposisi garam obat (salt composition) agar konsisten untuk perbandingan.

    Langkah-langkah:
    - Pisahkan komponen jika terdiri dari beberapa zat aktif yang digabung dengan '+'
    - Hilangkan teks dalam tanda kurung (misalnya dosis atau bentuk sediaan)
    - Ubah ke huruf kecil dan hapus spasi berlebih
    - Urutkan komponen secara alfabetis agar formatnya konsisten meskipun urutan awal berbeda

    Parameters:
    - comp: string komposisi garam, misalnya "Paracetamol (500mg) + Caffeine (30mg)"

    Returns:
    - Normalized string: "caffeine + paracetamol"
    """

    components = [c.split('(')[0].strip().lower() for c in comp.split('+')]
    return ' + '.join(sorted(components))

# Terapkan normalisasi ke kolom 'salt_composition' dan simpan ke kolom baru 'normalized_salt'
medicine_filtered['normalized_salt'] = medicine_filtered['salt_composition'].apply(normalize_salt_composition)

"""### Menggabungkan Fitur

Menggabungkan Fitur Sub Category dan Salt Composition menjadi Fitur Baru. Sebelum modelling , akan dibuat fitur baru yang merupakan gabungan dari sub category dan salt composition yang telah dinormalisasi. Menggabungkan dua fitur ini membantu membentuk representasi yang lebih lengkap dari setiap obat.
"""

# Menggabungkan fitur 'sub_category' dan 'normalized_salt' untuk membuat representasi teks gabungan
medicine_filtered['combined_text'] = medicine_filtered['sub_category'] + ' ' + medicine_filtered['normalized_salt']

"""### Pembuatan Matriks TD-*IDF*

Setelah fitur gabungan terbentuk, dilakukan proses transformasi teks menjadi representasi numerik menggunakan teknik TF-IDF (Term Frequency-Inverse Document Frequency). Teknik ini digunakan untuk mengukur pentingnya suatu kata dalam sebuah dokumen relatif terhadap kumpulan dokumen lainnya. Matriks ini memungkinkan sistem rekomendasi menghitung tingkat kemiripan antar obat menggunakan ukuran seperti cosine similarity
"""

# Inisialisasi vectorizer untuk menghitung bobot TF-IDF dari teks gabungan
vectorizer = TfidfVectorizer()

# Transformasi teks menjadi matriks TF-IDF
tfidf_matrix = vectorizer.fit_transform(medicine_filtered['combined_text'])

# Melihat ukuran matriks TF-IDF: (jumlah produk, jumlah fitur unik)
tfidf_matrix.shape

# Melihat bentuk padat dari matriks TF-IDF
tfidf_matrix.todense()

# Membuat DataFrame dari matriks TF-IDF untuk melihat bobot setiap kata pada beberapa produk secara acak

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=vectorizer.get_feature_names_out(),
    index=medicine_filtered['product_name']
).sample(10, axis=0).sample(10, axis=1).round(2) # Memilih 5 produk secara acak dan 10 kata fitur

"""### Perhitungan cosine similarity antar produk

Setelah matriks TF-IDF terbentuk, langkah berikutnya adalah menghitung cosine similarity antara vektor-vektor TF-IDF dari setiap produk obat. Ini digunakan untuk merepresentasikan seberapa mirip dua obat tersebut berdasarkan kombinasi sub_category dan salt_composition. engan menggunakan metrik ini, sistem dapat menentukan obat-obat mana yang memiliki kemiripan konten paling tinggi dan merekomendasikan obat pengganti yang relevan sesuai kebutuhan pengguna.
"""

# Mengitung cosine similarity antar produk
cosine_similarities = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Membuat DataFrame untuk menampilkan hubungan antara produk dan fitur
cosine_sim_df = pd.DataFrame(cosine_similarities, columns=medicine_filtered['product_name'], index=medicine_filtered['product_name'])

# Menampilkan matriks hubungan
print('Shape:', cosine_sim_df.shape)
cosine_sim_df.sample(10, axis=1).sample(7, axis=0).round(2)

"""## Modeling

Teknik yang digunakan untuk membangun sistem rekomendasi obat perngganti adalah _content-based filtering_. _Content-based filtering_ digunakan dalam sistem rekomendasi untuk menyarankan item kepada pengguna berdasarkan kesamaan atribut atau fitur yang ada pada item tersebut. Teknik ini cocok untuk rekomendasi pengganti obat, di mana sistem menganalisis karakteristik obat utama, seperti kandungan zat aktif, indikasi, dan kategori, lalu mencocokkannya dengan obat lain yang memiliki fitur serupa. Dengan cara ini, sistem dapat memberikan rekomendasi obat pengganti yang relevan dan sesuai kebutuhan. Penerapan teknik ini mempercepat dan mempermudah pencarian obat pengganti yang tepat, sekaligus mengurangi risiko kesalahan pengobatan akibat pemilihan alternatif obat yang tidak tepat.

### Pembuatan Fungsi Sistem Rekomendasi

Pada bagain ini, dibuat fungsi yang digunakan untuk merekomendasikan obat-obatan yang mirip berdasarkan kemiripan teks, dengan memanfaatkan matriks TF-IDF dan perhitungan cosine similarity. Fungsi ini menerima nama produk yang ingin dicari rekomendasinya, matriks TF-IDF dari fitur obat, DataFrame berisi data obat, serta jumlah obat mirip (top_n) yang ingin direkomendasikan.
"""

def recommend_similar_meds(product_name, tfidf_matrix, df, top_n=10):

    """
    Memberikan rekomendasi obat yang mirip berdasarkan kemiripan teks (TF-IDF + Cosine Similarity).

    Parameters:
    - product_name: nama produk obat yang ingin dicari rekomendasinya
    - tfidf_matrix: matriks hasil transformasi TF-IDF dari deskripsi atau fitur obat
    - df: DataFrame berisi data obat (harus sesuai dengan tfidf_matrix)
    - top_n: jumlah obat mirip yang ingin direkomendasikan

    Returns:
    - DataFrame berisi top_n obat yang paling mirip (nama produk, sub kategori, dan komposisi garam)
    """

    # Mencari index produk yang cocok dengan nama yang diberikan
    idx = medicine_filtered[medicine_filtered['product_name'] == product_name].index[0]

    # Mengambil indeks produk dengan similarity tertinggi, kecuali dirinya sendiri
    similar_indices = cosine_similarities[idx].argsort()[-top_n-1:-1][::-1]

    # Mengammbil dan kembalikan data produk mirip beserta informasi relevan
    return medicine_filtered.iloc[similar_indices][['product_name', 'sub_category', 'salt_composition']]

# Menampilkan dataframe obat yang ingin digantik
medicine_filtered[medicine_filtered['product_name'] == 'Natflu 75mg Capsule'][['product_name', 'sub_category', 'salt_composition']]

# Contoh penggunaan fungsi:

recommend_similar_meds("Natflu 75mg Capsule", tfidf_matrix, medicine_filtered, top_n=5)

"""**bold text**## Evaluation

Pada model _content-based filtering_, metrik evaluasi yang digunakan adalah **precision** atau presisi. Presisi mengukur sejauh mana model berhasil mengklasifikasikan item relevan di antara semua prediksi positif yang dihasilkan. Dalam sistem rekomendasi, presisi mengukur seberapa relevan item yang direkomendasikan dengan preferensi pengguna. Metrik ini dihitung dengan membandingkan jumlah item relevan yang direkomendasikan dengan total item yang direkomendasikan.

Pemilihan presisi sangat relevan untuk proyek ini karena tujuan sistem adalah memberikan rekomendasi obat pengganti yang tepat berdasarkan kesamaan kategori dan komposisi. Fokus pada presisi memastikan bahwa rekomendasi yang diberikan tidak hanya banyak, tetapi juga akurat dan sesuai dengan kebutuhan pengguna, mengurangi kemungkinan memberikan saran yang tidak relevan.

### Fungsi Penentuan Ground Truth

Fungsi ini digunakan untuk mencari produk obat pengganti yang relevan berdasarkan kesamaan *sub category* dan *salt composition*. Fungsi ini berguna sebagai *ground truth* untuk mengevaluasi hasil rekomendasi yang digunakan sebagai pembanding untuk hasil rekomendasi yang dihasilkan oleh sistem
"""

def get_relevant_based_on_both(product_name, df):
    """
    Mengambil daftar produk relevan berdasarkan kesamaan sub kategori dan komposisi (salt composition).

    Parameter:
    - product_name: nama produk yang ingin dicari padanannya
    - df: DataFrame yang berisi data produk (harus mengandung kolom 'product_name', 'sub_category', dan 'normalized_salt')

    Fungsi ini akan mengembalikan daftar produk lain yang memiliki:
    - sub kategori yang sama
    - komposisi garam (salt) yang sama
    - nama produk yang berbeda (tidak mengembalikan dirinya sendiri)

    Jika produk tidak ditemukan atau terjadi error, maka akan mengembalikan list kosong.
    """
    try:
        # Ambil satu baris data dari DataFrame yang sesuai dengan nama produk yang diberikan
        prod = df[df['product_name'] == product_name].iloc[0]

        # Ambil nilai sub kategori dan salt composition dari produk tersebut
        sub_cat = prod['sub_category']
        salt = prod['normalized_salt']

        # Cari produk lain yang memiliki sub kategori dan salt yang sama, tetapi bukan produk itu sendiri
        relevant = df[
            (df['sub_category'] == sub_cat) &
            (df['normalized_salt'] == salt) &
            (df['product_name'] != product_name)
        ]['product_name'].tolist()

        return relevant

    except:
        # Jika terjadi kesalahan (misalnya produk tidak ditemukan), kembalikan list kosong
        return []

"""### Fungsi Menghitung Presisi

Pada bagian ini akan dibuat 2 jenis fungsi yaitu :

Fungsi precision_at_k menghitung Precision@K, yaitu proporsi item relevan dari K rekomendasi teratas. Fungsi ini membandingkan daftar rekomendasi dengan data relevan (ground truth) dan menghitung seberapa banyak rekomendasi yang benar di antara K item pertama.

Fungsi evaluate_precision_at_k menghitung Precision@K untuk semua produk dalam dataset. Fungsi ini menerima rekomendasi dan data relevan untuk tiap produk, lalu mengembalikan rata-rata precision keseluruhan serta detail precision untuk setiap produk.
"""

# Fungsi untuk menghitung Precision@K
def precision_at_k(recommended, relevant, k=5):
    """
    Menghitung Precision@K.
    Precision@K adalah rasio item yang relevan di antara K item yang direkomendasikan teratas.

    Parameters:
    - recommended: list item yang direkomendasikan
    - relevant: set item yang dianggap relevan (ground truth)
    - k: jumlah item teratas yang akan dievaluasi

    Returns:
    - Precision@K (float)
    """
    recommended = recommended[:k]
    recommended_set = set(recommended)
    relevant_set = set(relevant)

    # Precision = Relevant in top-K / Total in top-K
    return len(recommended_set & relevant_set) / k if k > 0 else 0.0


# Fungsi utama untuk evaluasi precision dari semua produk
def evaluate_precision_at_k(all_recommendations, all_relevant, k=5):
    """
    Mengevaluasi Precision@K untuk semua produk yang diuji.

    Parameters:
    - all_recommendations: dictionary {produk: list rekomendasi}
    - all_relevant: dictionary {produk: set item relevan}
    - k: jumlah item teratas yang dipertimbangkan

    Returns:
    - Rata-rata precision semua produk
    - Detail hasil evaluasi per produk
    """
    precision_scores = []
    recommendation_details = {}

    for product in all_recommendations:
        recommended = all_recommendations[product]
        relevant = all_relevant.get(product, set())

        precision = precision_at_k(recommended, relevant, k)

        # Simpan detail evaluasi untuk setiap produk
        recommendation_details[product] = {
            'recommended': recommended[:k],
            'relevant': list(relevant),
            'precision_at_k': precision
        }

        precision_scores.append(precision)

    # Hitung rata-rata precision dari seluruh produk
    avg_precision = np.mean(precision_scores)

    return avg_precision, recommendation_details

"""### Perhitungan Presisi

Bagian ini akan melakukan pengujian dan evaluasi sistem rekomendasi obat pengganti berbasis content-based filtering. Pertama, daftar produk yang akan diuji didefinisikan di products_to_test. Selanjutnya, ground truth untuk tiap produk dibuat dengan memanggil fungsi get_relevant_based_on_both untuk mendapatkan daftar produk relevan berdasarkan sub category dan salt composition.

Setelah itu, untuk setiap produk, sistem rekomendasi dipanggil melalui fungsi recommend_similar_meds yang menghasilkan daftar 5 obat pengganti teratas. Hasil rekomendasi tersebut disimpan dalam all_recommendations.

Kemudian, fungsi evaluate_precision_at_k digunakan untuk menghitung rata-rata Precision@5 dari semua produk, yaitu seberapa tepat rekomendasi dalam 5 teratas dibandingkan ground truth. Terakhir, hasil evaluasi beserta rekomendasi dan data relevan untuk tiap produk ditampilkan secara terperinci.
"""

# Daftar produk yang akan diuji sistem rekomendasinya
products_to_test = ["Natflu 75mg Capsule", "Huminsulin N 40IU/ml Injection", "Alrista Plus Tablet SR"]

# Ground truth: produk relevan ditentukan berdasarkan sub kategori (bisa juga dengan salt composition)
ground_truth = {
    "Natflu 75mg Capsule": set(get_relevant_based_on_both("Natflu 75mg Capsule", medicine_filtered)),
    "Huminsulin N 40IU/ml Injection": set(get_relevant_based_on_both("Huminsulin N 40IU/ml Injection", medicine_filtered)),
    "Alrista Plus Tablet SR": set(get_relevant_based_on_both("Alrista Plus Tablet SR", medicine_filtered)),
}

# Hitung rekomendasi obat untuk setiap produk
all_recommendations = {}
for product in products_to_test:
    try:
        # Panggil fungsi sistem rekomendasi (misalnya berbasis TF-IDF)
        recs = recommend_similar_meds(product, tfidf_matrix, medicine_filtered, top_n=5)
        all_recommendations[product] = recs['product_name'].tolist()
    except Exception as e:
        print(f"Error recommending for {product}: {e}")
        all_recommendations[product] = []

# Evaluasi sistem rekomendasi menggunakan Precision@K
avg_precision, recommendation_details = evaluate_precision_at_k(all_recommendations, ground_truth, k=5)

# Menampilkan hasil evaluasi
print(f"Average Precision@5: {avg_precision:.4f}")
print("\nRekomendasi Obat Beserta Evaluasi Precision@5:\n")

for product, details in recommendation_details.items():
    print(f"Produk: {product}")
    print(f"Rekomendasi (Top-5): {details['recommended']}")
    print(f"Relevansi: {details['relevant']}")
    print(f"Precision@5: {details['precision_at_k']:.4f}")
    print("-" * 50)

"""Dari hasil evaluasi dapat dilihat bahwa  sistem berhasil merekomendasikan lima obat yang relevan berdasarkan kesamaan kategori dan komposisi.
Untuk **Natflu 75mg Capsule**, kelima rekomendasi yang diberikan memiliki relevansi yang sama, menghasilkan **precision\@5** sebesar 1.0, yang berarti semua rekomendasi relevan. Hal yang sama juga berlaku untuk **Huminsulin N 40IU/ml Injection** dan **Alrista Plus Tablet SR**, dengan **precision\@5** masing-masing mencapai 1.0, menunjukkan bahwa semua rekomendasi yang diberikan sesuai dengan kebutuhan dan preferensi pengguna.

Secara keseluruhan, hasil ini menunjukkan bahwa sistem rekomendasi berbasis **content-based filtering** memberikan rekomendasi yang sangat akurat, dengan **precision\@5** mencapai nilai sempurna (1.0) untuk setiap produk.

## Catatan Reviewer Sebelumnya

### Notebook Documentation

#### Terdapat variabel yang tidak didefinisikan sebelumnya.

Jika ada variabel yang belum didefinisikan, program akan menghasilkan error saat dijalankan ulang dan output yang muncul bisa jadi tidak valid. Sebaiknya periksa dan lengkapi definisi setiap variabel sebelum menjalankan kembali.

![image.png](data:image/png;base64,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)

#### Memberikan dokumentasi pada setiap baris kode atau fungsi kode menggunakan markdown/text cell pada Notebook

Penjelasan yang dimaksud meliputi:
* Penjelasan terkait proses yang dilakukan.
Contoh: Terdapat missing value pada dataset maka kamu perlu menyinggung metode apa yang digunakan untuk mengisi nilai kosong tersebut.
* Penjelasan terkait hasil dari proses yang telah dijalankan.
Contoh: Kamu telah melakukan eksplorasi data maka kamu perlu menyinggung insight apa yang didapatkan dari hasil eksplorasinya tersebut.

### Data Preparation

Kamu belum menuliskan seluruh tahapan data preparation yang kamu lakukan, silahkan tambahkan tahapan TFIDF dan sebagainya. Pastikan tahapan pemrosesan data urut dan lengkap sesuai yang ada pada notebook.
"""